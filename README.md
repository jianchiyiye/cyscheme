# cyscheme
cy to scheme 
使用scheme进行cy文件解析，生成cyl文件和ss文件。

cy文档格式：纯文本文件。但需要符合特定的规则。
cy文件有词语和分隔符串组成。词语又包括标识符，y表达式，@表达式，s表达式，c表达式，常量等语法单位。
在cy文件中，#，@，[和]，(和)，{和}，、...有特殊含义，称为特殊符号。
我们用<>来包围一个符号或者控制符。
首先我们定义cy文件中的语法单位间的分隔符：<空格>，
<回车>，<制表符>，<，>，<。>，<；>，<：>。
由一个或者多个连续分隔符组成的分隔符称为连续分隔符串，简称为分隔符串。
分隔符串之间的符号串我们称为词语。
以<#>开头的词语我们称为#常量，包括字符常量，字符串常量，二进制常数，八进制常数，十六进制常数，十进制常数，系统常量，扩展常量，列表常量，单行注释，多行注释，开发注释等。
以<">开始，<">结尾的词语我们称为字符串，它与字符串常量等价。也是常量的一种。
符合整数，小数，分数，指数数规则的词语我们称为数值常量。
#常量，字符串，数值常量都是常量（除注释外），都可以用于任何使用常量的位置。
除常量以外的词语都是变量名或者函数名。
一个不包含特殊符号的词语我们称为标识符，可能是变量名，也可能是无参函数名。
规则是缺省默认是局部变量名，如果是已经或者随后进行了函数定义，则该标识符就变为无参函数名。
一个词语中以<(>开头，配对的<)>结束的词语我们称为s表达式。注意：s表达式后必须后跟分隔符串，这是与
一个词语中以<{>开头，配对的<}>结束的词语我们称为c表达式。
s表达式和c表达式是cy语言的宿主编程语言和外部编程语言，用于解决语义的计算机解析。我们把它们通称为编程语言。
一个包含配对[]的词语我们称为y表达式。
其中用[]包围起来的词语，我们称为参数分段。在[]外部的部分，我们称为函数名分段。这里支持嵌套[]。
比如：[a]-[[10]+[b]]，[10]+[b]作为整体是参数分段，但其中的+却是这个参数中的函数名分段。
y表达式都是函数名。其中可以包含任意多配对[]。
@表达式有两种形式：变量@表达式，函数@表达式。
变量@表达式的格式是：变量名@常量，
其严格意义如下：如果变量名以前没有定义，则定义为局部变量，在函数初始化段赋值。
如果变量名以前在函数外部定义过，则在函数内部屏蔽外部的同名变量。函数结束后，该变量仍保留以前的外部定义值。
如果变量名以前在函数内部定义过，则提示出错。
两种特殊形式：1，变量名<==>变量名@#空，即没有@形式的变量名被缺省定义为空值。
2，变量名@，则表示变量不在函数内定义，使用外部值。如果该变量名在外部没有定义过，则补充定义为空值变量。
特别注意：当变量名值变为无参函数时，初始化赋值的是同名无参函数的内部变量。

函数@表达式仅用于函数名定义时。
其格式是：1，函数名@所属函数名，该形式代表函数名所定义的函数是所属函数名函数的内部片段函数。直白说就是一个局部宏。
，其它函数不能引用，也不会与其它同名函数或宏冲突。
2，函数名@$位置编码-运行方式
位置编码则是针对cyl文档中的某一个位置。
而运行方式只有两种：1，前置运行。2，后置运行。这种函数仅在cyl编辑环境内支持。
如果位置编码处代码被删除，则该位置函数将不会运行。
总结一下，词语在开始处会根据<#>，<">，<(>，<{>确定进入哪一种词语输入。如果第一个字符不是特殊字符，则这些特殊字符也可以作为标识符中的字符。
只有<@>，<[>，<(>不可以随意使用，除了在字符串中使用外，不可以作为标识符字符使用。
<{>仅允许使用在函数定义开始。
中文宏定义：
1，如果宏标准格式：如果，条件函数，那么，执行真函数1，执行真函数2，…；否则，执行假函数1，执行假函数2，…。
其它格式：a，如果，条件函数，执行真函数。
b，如果，条件函数，执行真函数；否则，执行假函数。
2，分类宏标准格式：分类：若，条件函数1，执行真函数11，执行真函数12，…；若，条件函数2，执行真函数21，执行真函数22，…；…；否则，执行假函数1，执行假函数2，…。
其它格式：a，分类：若，条件函数，执行真函数。
b，分类：否则，执行函数。
3，循环标准格式：循环：语句1，语句2，…。（语句中必须包括退出语句，防止形成死循环。）
4，遍历标准格式：遍历，列表名，针对每个（索引，元素，子项），遍历引导变量：语句1，语句2，…。
5，注册标准格式：注册：注册类型名，（类型子类1，类型子类2，…）=（值1，值2，…）。
其它格式：a，注册[类型]，归属子类：属性=值。
b，注册[包]，包名称=包保存位置。
c，注册[别名]，别名值=标准名值。

函数书写格式：函数名只能是标识符，一阶纯符号y表达式，函数@表达式。
函数名\n\t函数体。\n
函数体中尽量不使用嵌套宏，使用片段函数把嵌套宏分解到下一级。
如果书写嵌套宏有利于语义理解，那么尽可能不让两个宏的终结处重合。实在无法避免，则使用“宏终结语句。”来完成上一个嵌套宏。
